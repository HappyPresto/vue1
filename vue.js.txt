1 Lesson:

- Как Vue.js хранит данные:
Если наш класс, контролируется объектом Vue (например sample), то когда мы пишем name, то мы
фактически обращаемся к sample.name .
В Vue есть 4 основных ключа, в которых мы описываем данные метода:
1) data - обычные данные 
2) computed - данные вычисляемые на основании других (вызываются один раз) (нельзя использовать при асинхронных операциях, т.к. значение надо получить прямо сейчас)
3) methods - методы, которые у этого объекта есть (вызываются при каждом ререндере шаблона)
4) watch - указываем, какие поля мы будем прослушивать
Не смотря на то, что все это мы описываем, как отдельные объекты, все собирается и пристраивается
к нашему объекту, который будет получен. Vue так ставит ссылки, на эти объекты, что мы сразу
можем обратиться к свойству, только что созданного этого объекта

- Директивы:
Все директивы vue начинаются с "v-". Директив немного, около 10-20 штук, но так же можно написать
свои директивы.
В директиве мы можем указать ссылку на метод, который есть у нашего объекта.
Любой код, которые напишем в директиве, работает в контексте данного объекта Vue
(в JS обработчики события на элементе DOM всегда работают в контексте этого эл-та DOM).
т.е. если мы захотим получить value, то this.value мы не получим value. Потому что этот код
выполняется в контексте двнного объекта Vue (new Vue)
Список директив:
1) v-on
событие
(вместо v-on можно писать @)
v-on:input="" 
мы не можем получить значение через input, т.к. мы потеряли ссылку на наш input. Ссылку на input
можно получить через "$event" ($event.target.value)
<input type="text" 
    v-on:input="name = $event.target.value"
>
v-on:change="" - сработает как input, только после анфокуса
v-on:click
2) v-bind
Атрибут
(вместо v-bind можно писать :)
Присваивает input"у значение из объекта Vue
v-bind:value="name"
3) v-if
Удаляет эл-т из DOM
<h2 v-if="showName">Hello, {{name}}</h2>
Делает проверку
(включает директиву v-else и v-else-if)
Если нужно вывести 2 элемента в v-else, но не хочется делать контейнер для эл-тов, то можно
использовать template. Тогда при рендере template уберется и выведутся только эл-ты (используется как узел)
4) v-show
Ставит эл-т в display: none
(работает быстрее, чем if, т.к. не нужно перерисовывать компонент)
5) v-for 
Цикл 
<li v-for="number in numbers"></li> - генерируется столько раз, сколько элементов в массиве
6) v-text
Равносилен интерполяции
7) v-html 
аналог innerHTML
8) v-model 
Событие + атрибут
9) v-pre
Пропустить компиляцию (повышаем производительность)
10) v-cloak
Скрыть до рендеринга
11) v-once
срендерить единожды

Объекты не реактивны на добавление новых свойств, поэтому, стоит использовать $set
$set
this.$set(this.guests, this.guestInterator, "");
встроенный метод в Vue.js, которое позволяет добавить реактивное поле к нашему объеку
------
this.$el - свойство экземпляра Vue 
this.$emit - генерирует событие отправляющееся родительскому элементу
------
Поля массива - не реактивны, поэтому для этого нужно использовать 
this.$set(this.guest, index, e.target.value) - Примерно так работает v-model
------
В массив guest добавляется строка / объект с индексом i:
this.$set(this.guests, i '')
если добавлять через this.guest[i] = ... , то никакой реактивности не будет.

Если в массив, положить объект, то т.к. он имеет геттер и сеттер, то ему не нужно задавать значение через $set, 
т.к. он уже изначально будет реактивным. Однако, если в массиве будем хранить просто значение, то это значение,
не будет иметь геттеры и сеттеры, соот-но, нужно задавать значение через $set, иначе не будет реактивности.

Если мне нужно добавить какое-либо поле в объект, то тут придется использовать $set для реактивности.

hook 
Подвешивание события (аля ивентовая события в браузере)
Хуки жизненного цикла:
-> beforeCreate - вызывается сразу после конструктора (до передачи геттеров и сеттеров объектов даты)
-> created - вызывается после создание реактивности, но в браузере еще ничего нету
-> beforeMount - когда шаблон получен, но еще не начали рендерить
-> mounted - когда эл-т сгенерирован в DOM
-> beforeUpdate
-> updated
-> activated
-> deactivated
-> beforeDestroy
-> destroyed

- Модификаторы:
Модификаторы событий, они меняет какие то настройки.
Модификаторы событий это то, что меняет их поведение, время срабатывания этого callbackа
.prevent - добавляет настройку e.prevent.default
.lazy - ставит в инпут событие change, а change сработает только при потери фокуса
.trim - удаляет проблемы слева и справа
Можно использовать 2 Модификатора сразу

- Создание директивы:
Vue.directive('v-timer', {
    bind(el, binding) {}
}

Хуки:
-> bind - вызывается однократно, при первичном связывании директивы с элементом. 
-> inserted - вызываетя после вставки связанного элемента внутрь элемента родителя
-> update - вызывается после обновлени VNode компонента-контейнера, но, возможно, обновления дочерних элементов.
-> componentUpdate - вызывается после обновление, как VNode, так и его потомков
-> unbind - вызывается однократно, при отвязывании директивы от элемента
Аргументы хуков:
el - Элемент к которому привязана директива, можно использовать для манипуляций с DOM
binding - Объект содержащий свойства
    -> name - Название директивы без префикса v-
    -> value - Значение, переданное в директиву (v-my-directive = "1 + 1")
    -> oldValue - предыдущее переданное в директиву значение. Доступно только для хуков
    -> update/componentUpdate - передается независимо от того, произошло ли в действительности его изменение
    -> expression - Выражение-строка, переданное в директиву. Например для v-my-directive = "1 + 1", это будет "1 + 1"
    -> arg - Аргумент, переданный в директиву, в случае его наличия. (v-my-directive:foo) = foo
    -> modifiers - Объект, содержащий модификаторы (если они есть). например, для v-my-directive.foo.bar, объектом модификаторов будет {foo:true, bar:true}
vnode - Виртуальный элемент, созданный компилятором Vue
oldVnode - Предыдущий виртуальный элемент, доступный для хуков update и componentUpdate

<keep-alive>
Все компоненты, которые объявлены внутри, хранятся в памяти и не пересоздаются

<style scoped> Стили доступны только в этом компоненте

Миксины - объект, который описывается по тем же правилам что и компонент.
(используются не очень часто)
let mixinUpdatesLogger = {
  data: {
    updates: 0
  },
  updated() {
    this.updates++;
  }
}
Есть 2 способа внедрить mixin в экземпляры:
1) Глобальная регистрация
Vue.mixin() 
Но так делать не стоит, т.к. объявляя его глобально, миксин будет встроен в каждый поднимаемый экземпляр Vue
2) Локально (в самом экземпляре)
new Vue({
    el: '.sample',
    data: {
        show: true,
    }.
    mixins: [mixinUpdatesLogger]
})

Filters
(filters, как и methods, обрабатываются при каждом событии)
Filters - объект, где мы пишем методы, которые у нас есть. Нужно передавать хотя бы 1 параметр. Сработает в шаблоне 
только после того, как мы поставим | - {{ text | legth}}
{{ text | legth | upper}}
Удобнее методов в том, что можно применить 1+ фильтр на один и тот же элемент, в отличии от methods
В some передастся то значение, к которому применен фильтр (в данном случае - text)
new Vue({
  data: {
    updates: 0
  },
  filters: {
      length(some) {
          return ...
      },
      upper(str) {
          return ...
      }
  }
})

Стили
Стили записываются в 			
<transition name="fade" appear>
	<div class="alert alert-success" v-show="show">
		<div>Some text about some</div>
	</div>
</transition>
В стилях имеет 6 классов:
- fade-enter - добавляется на секунду, что бы считать начальные свойства
- fade-enter-active - когда начинает работать анимации
- fade-enter-to - когда начинает работать анимации (остается еще буквально на доли секунды, после того как наша анимация завершилась)
- fade-leave
- fade-leave-active
- fade-leave-to